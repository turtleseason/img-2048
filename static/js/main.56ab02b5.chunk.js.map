{"version":3,"sources":["types/tile.ts","assets/images.ts","assets/tile2.png","assets/tile4.png","assets/tile8.png","assets/tile16.png","assets/tile32.png","assets/tile64.png","assets/tile128.png","assets/tile256.png","assets/tile512.png","assets/tile1024.png","assets/tile2048.png","types/direction.ts","game/GameLogic.ts","util.ts","game/GameTile.tsx","game/GameBoard.tsx","hooks/useMountEffect.ts","game/Game.tsx","ImageDialog.tsx","SettingsDrawer.tsx","App.tsx","reportWebVitals.js","index.tsx"],"names":["Tile","id","value","this","images","tile2","tile4","tile8","tile16","tile32","tile64","tile128","tile256","tile512","tile1024","tile2048","Directions","arrowKeys","indexFromCoords","col","row","rowFromIndex","index","Math","floor","colFromIndex","getNextValue","undefined","random","getOpenPosition","tiles","tileCount","reduce","total","current","openSpacesCount","max","selectedSpace","i","indexOf","rotateLeft","rotations","Error","result","Array","newCol","newRow","r","temp","PUZZLE_SIZE","moveLeft","moved","highestMerge","tile","column","nextTile","neighbors","push","imageUrl","GameTile","size","spacing","rest","Fade","timeout","Box","position","top","left","width","height","borderRadius","bgcolor","fontSize","display","justifyContent","alignItems","sx","backgroundImage","backgroundSize","transition","GameBoard","fn","onWin","onLose","useState","fill","setTiles","nextId","setNextId","canMove","setCanMove","spawnTile","useCallback","pos","newTiles","slice","console","error","handleKeyDown","e","key","preventDefault","direction","moveResults","move","setTimeout","neighbor","hasPossibleMoves","image","Image","src","prefetchImages","useEffect","document","addEventListener","removeEventListener","tileSpacing","padding","TransitionGroup","component","map","filter","x","sort","a","b","Game","game","setGame","won","setWon","lose","setLose","Stack","Typography","variant","fontWeight","mt","Grid","container","maxWidth","item","flexShrink","pr","Button","onClick","endIcon","xs","ImageDialog","isOpen","setOpen","Dialog","open","onClose","scroll","aria-labelledby","DialogTitle","DialogContent","DialogActions","SettingsDrawer","setImageDialogOpen","checked","setChecked","Drawer","anchor","List","subheader","ListSubheader","mx","ListItem","divider","ListItemIcon","ListItemText","primary","Switch","edge","onChange","inputProps","ListItemButton","App","menuOpen","setMenuOpen","dialogOpen","setDialogOpen","AppBar","Toolbar","IconButton","color","aria-label","mr","flexGrow","Container","my","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","CssBaseline","getElementById"],"mappings":"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","file":"static/js/main.56ab02b5.chunk.js","sourcesContent":["export class Tile {\r\n    id: number;\r\n    value: any;\r\n\r\n    constructor(id: number, value: any) {\r\n        this.id = id;\r\n        this.value = value;\r\n    }\r\n}","import tile2 from './tile2.png';\r\nimport tile4 from './tile4.png';\r\nimport tile8 from './tile8.png';\r\nimport tile16 from './tile16.png';\r\nimport tile32 from './tile32.png';\r\nimport tile64 from './tile64.png';\r\nimport tile128 from './tile128.png';\r\nimport tile256 from './tile256.png';\r\nimport tile512 from './tile512.png';\r\nimport tile1024 from './tile1024.png';\r\nimport tile2048 from './tile2048.png';\r\n\r\nconst images = {\r\n    tile2,\r\n    tile4,\r\n    tile8,\r\n    tile16,\r\n    tile32,\r\n    tile64,\r\n    tile128,\r\n    tile256,\r\n    tile512,\r\n    tile1024,\r\n    tile2048,\r\n};\r\n\r\nexport default images;","export default __webpack_public_path__ + \"static/media/tile2.7c00f168.png\";","export default __webpack_public_path__ + \"static/media/tile4.e23e327d.png\";","export default __webpack_public_path__ + \"static/media/tile8.51e6ee33.png\";","export default __webpack_public_path__ + \"static/media/tile16.b16a6421.png\";","export default __webpack_public_path__ + \"static/media/tile32.f75c1227.png\";","export default __webpack_public_path__ + \"static/media/tile64.1a2f41ea.png\";","export default __webpack_public_path__ + \"static/media/tile128.7b283e7a.png\";","export default __webpack_public_path__ + \"static/media/tile256.a90db0cf.png\";","export default __webpack_public_path__ + \"static/media/tile512.2664c8f0.png\";","export default __webpack_public_path__ + \"static/media/tile1024.afeba609.png\";","export default __webpack_public_path__ + \"static/media/tile2048.e7247b69.png\";","export const Directions = {\r\n    Left: 'ArrowLeft',\r\n    Right: 'ArrowRight',\r\n    Up: 'ArrowUp',\r\n    Down: 'ArrowDown,'\r\n} as const;\r\nexport type Direction = typeof Directions[keyof typeof Directions];","// Static game methods\r\n\r\nimport { Direction, Directions } from \"../types/direction\";\r\nimport { Tile } from \"../types/tile\";\r\nimport { count, randomInt } from \"../util\";\r\n\r\nexport const PUZZLE_SIZE = 4;\r\nexport const BASE_VALUE = 2;\r\n\r\nexport const arrowKeys = {\r\n    'ArrowLeft': Directions.Left,\r\n    'ArrowRight': Directions.Right,\r\n    'ArrowUp': Directions.Up,\r\n    'ArrowDown': Directions.Down,\r\n}\r\n\r\nexport const indexFromCoords = (col: number, row: number) => {\r\n    return col + (row * PUZZLE_SIZE);\r\n}\r\n\r\nexport const rowFromIndex = (index: number) => {\r\n    return Math.floor(index / PUZZLE_SIZE);\r\n}\r\n\r\nexport const colFromIndex = (index: number) => {\r\n    return index % PUZZLE_SIZE;\r\n}\r\n\r\n// Gets the next value for a tile with the given value.\r\n// When called with no arguments, returns a value for a new tile.\r\nexport const getNextValue = (value?: any) => {\r\n    if (value === undefined) {\r\n        return Math.random() < .95 ? BASE_VALUE : BASE_VALUE ** 2;\r\n    }\r\n    return value * BASE_VALUE;\r\n}\r\n\r\n// Returns the index of a random empty position on the board, or -1 if the board is full.\r\nexport const getOpenPosition = (tiles: (Tile | null)[]): number => {\r\n    const tileCount = count(tiles);\r\n\r\n    const openSpacesCount = PUZZLE_SIZE ** 2 - tileCount;\r\n    if (openSpacesCount <= 0) {\r\n        return -1;\r\n    }\r\n\r\n    const selectedSpace = randomInt(openSpacesCount);\r\n\r\n    let index = -1;\r\n    for (let i = 0; i <= selectedSpace; i++) {\r\n        index = tiles.indexOf(null, index + 1);\r\n    }\r\n    return index;\r\n}\r\n\r\n// Moves all tiles on the board.\r\n// Returns the new board state and some information about what happened during the move:\r\n//      tiles: The new board state.\r\n//      moved: True if any tiles changed position, false if no tiles moved.\r\n//      highestMerge: If any tiles merged during the moved, this returns the highest new tile value;\r\n//                    if there were no merges, this is -1.\r\nexport const move = (direction: Direction, tiles: (Tile | null)[]) => {\r\n    let result = tiles.slice();\r\n\r\n    // Rotate the board so that we can always move left\r\n    if (direction === Directions.Up) {\r\n        result = rotateLeft(result, 1);\r\n    } else if (direction === Directions.Right) {\r\n        result = rotateLeft(result, 2);\r\n    } else if (direction === Directions.Down) {\r\n        result = rotateLeft(result, 3);\r\n    }\r\n\r\n    const moveResults = moveLeft(result);\r\n\r\n    if (direction === Directions.Up) {\r\n        result = rotateLeft(result, 3);\r\n    } else if (direction === Directions.Right) {\r\n        result = rotateLeft(result, 2);\r\n    } else if (direction === Directions.Down) {\r\n        result = rotateLeft(result, 1);\r\n    }\r\n\r\n    return { ...moveResults, tiles: result };\r\n}\r\n\r\n// Treats \"tiles\" as a (square) nested array of size PUZZLE_SIZE\r\n// and returns a new array with the contents rotated 90 degrees to the left. \r\nconst rotateLeft = (tiles: any[], rotations: number = 1) => {\r\n    if (rotations < 0) {\r\n        throw Error('rotateLeft: \"rotations\" must be non-negative');\r\n    }\r\n\r\n    const result = new Array(PUZZLE_SIZE ** 2);\r\n    for (let i = 0; i < PUZZLE_SIZE ** 2; i++) {\r\n        let newCol = colFromIndex(i);\r\n        let newRow = rowFromIndex(i);\r\n\r\n        for (let r = 0; r < rotations; r++) {\r\n            const temp = newRow;\r\n\r\n            newRow = PUZZLE_SIZE - 1 - newCol;\r\n            newCol = temp;\r\n        }\r\n\r\n        result[indexFromCoords(newCol, newRow)] = tiles[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n// (Mutates tiles)\r\nconst moveLeft = (tiles: (Tile | null)[]) => {\r\n    let moved = false;\r\n    let highestMerge = -1;\r\n\r\n    for (let index = 0; index < PUZZLE_SIZE ** 2; index++) {\r\n        let tile = tiles[index];\r\n        const column = colFromIndex(index);\r\n\r\n        for (let i = 1; i < PUZZLE_SIZE - column; i++) {\r\n            const nextTile = tiles[index + i];\r\n\r\n            if (nextTile && !tile) {\r\n                // Move tile into the open space\r\n                tiles[index] = nextTile;\r\n                tiles[index + i] = null;\r\n\r\n                moved = true;\r\n                // Continue checking tiles in case you need to merge\r\n                tile = nextTile;\r\n            } else if (nextTile) {\r\n                // Merge tiles if values match\r\n                if (nextTile.value === tile!.value) {\r\n                    nextTile.value = getNextValue(nextTile.value);\r\n                    tiles[index] = nextTile;\r\n                    tiles[index + i] = null;\r\n\r\n                    moved = true;\r\n                    highestMerge = Math.max(highestMerge, nextTile.value);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return { moved, highestMerge };\r\n}\r\n\r\nexport const hasPossibleMoves = (tiles: (Tile | null)[]) => {\r\n    for (let i = 0; i < PUZZLE_SIZE ** 2; i++) {\r\n        if (!tiles[i]) {\r\n            return true;\r\n        }\r\n\r\n        for (const neighbor of neighbors(i)) {\r\n            if (!tiles[neighbor] || tiles[neighbor]!.value === tiles[i]!.value) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// Returns indices of all adjacent tiles (top, left, bottom, right) within board bounds.\r\nconst neighbors = (index: number) => {\r\n    const col = colFromIndex(index);\r\n    const row = rowFromIndex(index);\r\n\r\n    const neighbors = [];\r\n    if (col > 0) neighbors.push(indexFromCoords(col - 1, row));\r\n    if (row > 0) neighbors.push(indexFromCoords(col, row - 1));\r\n    if (col < PUZZLE_SIZE - 1) neighbors.push(indexFromCoords(col + 1, row));\r\n    if (row < PUZZLE_SIZE - 1) neighbors.push(indexFromCoords(col, row + 1));\r\n\r\n    return neighbors;\r\n}\r\n","// Counts the number of truthy values in the array (for sparse arrays where length =/= count).\r\nexport function count(array: any[]) : number {\r\n    return array.reduce((total, current) => total + (!!current ? 1 : 0), 0)\r\n}\r\n\r\n// Returns an array containing int values from 0 (inclusive) to i (exclusive).\r\nexport function range(i: number) {\r\n    return Array.from(Array(i).keys());\r\n}\r\n\r\n// Returns a random integer between 0 (inclusive) and max (exclusive).\r\nexport function randomInt(max: number) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\n// Restricts x to the range between min and max (inclusive).\r\nexport function clamp(x: number, min: number, max: number) {\r\n    if (min > max) {\r\n        throw Error(`clamp: min (${min}) is greater than max (${max}).`);\r\n    }\r\n    return Math.max(Math.min(x, max), min);\r\n}\r\n\r\nexport function isEmptyOrWhitespace(str: string) {\r\n    const regExp = /^\\s*$/;\r\n    return regExp.test(str);\r\n}","import React from 'react';\r\nimport Box from '@material-ui/core/Box';\r\nimport Fade from '@material-ui/core/Fade';\r\nimport images from '../assets/images';\r\n\r\n// const customValues = {\r\n//     2: 115,\r\n//     4: 32,\r\n//     8: ' ',\r\n//     16: '...53891',\r\n//     32: 337,\r\n//     64: 202,\r\n//     128: '10211953503511126540...',\r\n//     256: '56209783',\r\n//     512: 'É˜ e',\r\n//     1024: '1',\r\n//     2048: '0',\r\n// };\r\n\r\nconst imageUrl = (value: number) => {\r\n    // @ts-ignore\r\n    return images[`tile${value}`];\r\n}\r\n\r\ninterface Props {\r\n    value: number;\r\n    row: number;\r\n    column: number;\r\n    size: number;\r\n    spacing: number;\r\n}\r\n\r\nconst GameTile = ({ value, row, column, size, spacing, ...rest }: Props) => {\r\n    return (\r\n        <Fade {...rest} timeout={100} >\r\n            <Box\r\n                position='absolute'\r\n                top={row * size + (row + 1) * spacing}\r\n                left={column * size + (column + 1) * spacing}\r\n                width={size}\r\n                height={size}\r\n                borderRadius={`${spacing / 2}px`}\r\n                bgcolor='primary.light'\r\n                fontSize={size * .33}\r\n                display='flex'\r\n                justifyContent='center'\r\n                alignItems='end'\r\n                sx={{\r\n                    backgroundImage: `url(${imageUrl(value)})`,\r\n                    backgroundSize: 'cover',\r\n                    transition: 'opacity .10s, top .25s, left .25s !important'\r\n                }}>\r\n                {/* {// @ts-ignore\r\n                value in customValues ? (customValues[value]) : value} */}\r\n            </Box>\r\n        </Fade>\r\n    )\r\n}\r\n\r\nexport default GameTile;","import React, { useCallback, useEffect, useState } from 'react';\r\n\r\nimport Box from '@material-ui/core/Box';\r\nimport { TransitionGroup } from 'react-transition-group';\r\n\r\nimport { useMountEffect } from '../hooks/useMountEffect';\r\nimport { Tile } from '../types/tile';\r\nimport images from '../assets/images';\r\n\r\nimport {\r\n    BASE_VALUE, PUZZLE_SIZE, arrowKeys, colFromIndex, rowFromIndex,\r\n    getNextValue, getOpenPosition, hasPossibleMoves, move\r\n} from './GameLogic';\r\nimport GameTile from './GameTile';\r\n\r\nconst prefetchImages = () => {\r\n    for (const image in images) {\r\n        new Image().src = image;\r\n    }\r\n}\r\n\r\ninterface Props {\r\n    onWin: () => void;\r\n    onLose: () => void;\r\n}\r\n\r\nexport default function GameBoard({ onWin, onLose }: Props) {\r\n    const [tiles, setTiles] = useState<(Tile | null)[]>(new Array(PUZZLE_SIZE ** 2).fill(null));\r\n    const [nextId, setNextId] = useState(1);\r\n    const [canMove, setCanMove] = useState(false);\r\n\r\n    const spawnTile = useCallback((tiles: (Tile | null)[]) => {\r\n        const pos = getOpenPosition(tiles);\r\n\r\n        const newTiles = tiles.slice();\r\n        if (pos >= 0) {\r\n            newTiles[pos] = new Tile(nextId, getNextValue());\r\n            setNextId(nextId + 1);\r\n        }\r\n        else {\r\n            console.error('spawnTiles: Tried to add tile to full board');\r\n        }\r\n        return newTiles;\r\n    }, [nextId]);\r\n\r\n    const handleKeyDown = useCallback((e: KeyboardEvent) => {\r\n        if (e.key in arrowKeys) {\r\n            e.preventDefault();\r\n\r\n            if (canMove) {\r\n                setCanMove(false);\r\n                const result = move(arrowKeys[e.key as keyof typeof arrowKeys], tiles.slice());\r\n                setTiles(result.tiles);\r\n\r\n                if (result.highestMerge === BASE_VALUE ** 11) {\r\n                    onWin();\r\n                }\r\n\r\n                if (result.moved) {\r\n                    setTimeout(() => {\r\n                        const newTiles = spawnTile(result.tiles);\r\n                        setTiles(newTiles);\r\n                        setCanMove(true);\r\n\r\n                        if (!hasPossibleMoves(newTiles)) {\r\n                            onLose();\r\n                        }\r\n                    }, 150);\r\n                } else {\r\n                    setCanMove(true);\r\n                }\r\n            }\r\n        }\r\n    }, [canMove, onLose, onWin, spawnTile, tiles]);\r\n\r\n    useMountEffect(() => {\r\n        prefetchImages();\r\n        setTiles(spawnTile(new Array(PUZZLE_SIZE ** 2).fill(null)));\r\n        setCanMove(true);\r\n    });\r\n\r\n    useEffect(() => {\r\n        document.addEventListener('keydown', handleKeyDown);\r\n        return () => document.removeEventListener('keydown', handleKeyDown);\r\n    }, [handleKeyDown]);\r\n\r\n    const tileSize = 100;\r\n    const tileSpacing = 10;\r\n\r\n    return (\r\n        <Box\r\n            width={PUZZLE_SIZE * (tileSize + tileSpacing) + tileSpacing}\r\n            height={PUZZLE_SIZE * (tileSize + tileSpacing) + tileSpacing}\r\n            bgcolor='primary.dark'\r\n            padding={tileSpacing}\r\n            position='relative'\r\n            borderRadius={`${tileSpacing}px`}\r\n        >\r\n            <TransitionGroup component={null}>\r\n                {\r\n                    // Sort tiles by ID when rendering to keep them in a consistent order (to avoid messing up CSS transitions),\r\n                    // but also keep track of the original index from 'tiles' which is needed to set the row/column position\r\n                    tiles.map((tile, index) => ({ tile, index }))\r\n                        .filter(x => !!x.tile)\r\n                        .sort((a, b) => a.tile!.id - b.tile!.id)\r\n                        .map(({ tile, index }) => tile ? (\r\n                            <GameTile\r\n                                key={tile.id}\r\n                                size={tileSize}\r\n                                spacing={tileSpacing}\r\n                                row={rowFromIndex(index)}\r\n                                column={colFromIndex(index)}\r\n                                value={tile.value}\r\n                            />\r\n                        ) : null)}\r\n            </TransitionGroup>\r\n        </Box>\r\n    )\r\n}","// https://stackoverflow.com/a/56767883\r\n// Hook for effects that should only run once, when the component is mounted.\r\n\r\nimport { useEffect } from \"react\"\r\n\r\n// eslint-disable-next-line react-hooks/exhaustive-deps\r\nexport const useMountEffect = (fn: any) => useEffect(fn, [])","import React, { useState } from 'react';\r\n\r\nimport Button from '@material-ui/core/Button';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Stack from '@material-ui/core/Stack';\r\nimport Typography from '@material-ui/core/Typography';\r\n\r\nimport ReplayIcon from '@material-ui/icons/Replay';\r\n\r\nimport GameBoard from './GameBoard';\r\n\r\nexport default function Game() {\r\n    const [game, setGame] = useState(1);\r\n    const [won, setWon] = useState(false);\r\n    const [lose, setLose] = useState(false);\r\n\r\n    const newGame = () => {\r\n        setGame(game + 1);\r\n        setWon(false);\r\n    }\r\n\r\n    return (\r\n        <Stack spacing={2}>\r\n            {won &&\r\n                <Typography variant='h5' fontWeight='bold' component='div' sx={{ mt: 1.5 }}>\r\n                    You won! congrat\r\n                </Typography>}\r\n            <GameBoard key={game} onWin={() => setWon(true)} onLose={() => setLose(true)} />\r\n            {lose &&\r\n                <Typography fontWeight='bold' component='div'>\r\n                    No more moves :(\r\n                </Typography>}\r\n            <Grid container direction='row' justifyContent='space-between' maxWidth='450px'>\r\n                <Grid item flexShrink={0} pr='1rem'>\r\n                    <Button\r\n                        onClick={newGame}\r\n                        variant='contained'\r\n                        endIcon={<ReplayIcon />}\r\n                    >\r\n                        New game\r\n                    </Button>\r\n                </Grid>\r\n                <Grid item xs>\r\n                    <span>Use the arrow keys to move the tiles. Merge matching tiles together to reach the 2048(?) tile!</span>\r\n                </Grid>\r\n            </Grid>\r\n        </Stack>\r\n    )\r\n}","import React from 'react';\r\n\r\nimport Button from '@material-ui/core/Button';\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport DialogActions from '@material-ui/core/DialogActions';\r\nimport DialogContent from '@material-ui/core/DialogContent';\r\nimport DialogTitle from '@material-ui/core/DialogTitle';\r\n\r\ninterface Props {\r\n    isOpen: boolean;\r\n    setOpen: (isOpen: boolean) => void;\r\n}\r\n\r\nexport default function ImageDialog({ isOpen, setOpen }: Props) {\r\n    return (\r\n        <Dialog\r\n            open={isOpen}\r\n            onClose={() => setOpen(false)}\r\n            scroll='paper'\r\n            aria-labelledby='image-dialog-title'\r\n        >\r\n            <DialogTitle id='image-dialog-title'>Choose custom images</DialogTitle>\r\n            <DialogContent>\r\n                Image selection goes here\r\n            </DialogContent>\r\n            <DialogActions>\r\n                <Button onClick={() => setOpen(false)}>Cancel</Button>\r\n                <Button onClick={() => setOpen(false)}>Apply</Button>\r\n            </DialogActions>\r\n        </Dialog>\r\n    )\r\n}","import React, { useState } from 'react';\r\n\r\nimport Drawer from '@material-ui/core/Drawer';\r\nimport List from '@material-ui/core/List';\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport ListItemButton from '@material-ui/core/ListItemButton';\r\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\r\nimport ListItemText from '@material-ui/core/ListItemText';\r\nimport ListSubheader from '@material-ui/core/ListSubheader';\r\nimport Switch from '@material-ui/core/Switch';\r\n\r\nimport BrightnessMediumIcon from '@material-ui/icons/BrightnessMedium';\r\nimport ImageIcon from '@material-ui/icons/Image';\r\n\r\ninterface Props {\r\n    isOpen: boolean;\r\n    setOpen: (isOpen: boolean) => void;\r\n    setImageDialogOpen: (isOpen: boolean) => void;\r\n}\r\n\r\nexport default function SettingsDrawer({ isOpen, setOpen, setImageDialogOpen }: Props) {\r\n    const [checked, setChecked] = useState(false);\r\n\r\n    return (\r\n        <Drawer\r\n            anchor='left'\r\n            open={isOpen}\r\n            onClose={() => setOpen(false)}\r\n        >\r\n            <List\r\n                subheader={(<ListSubheader>Settings</ListSubheader>)}\r\n                sx={{ mx: '.5rem' }}\r\n            >\r\n                <ListItem divider={true}>\r\n                    <ListItemIcon>\r\n                        <BrightnessMediumIcon />\r\n                    </ListItemIcon>\r\n                    <ListItemText id='switch-setting' primary='Setting' />\r\n                    <Switch\r\n                        edge='end'\r\n                        checked={checked}\r\n                        onChange={() => setChecked(!checked)}\r\n                        inputProps={{ 'aria-labelledby': 'switch-setting' }}\r\n                    />\r\n                </ListItem>\r\n\r\n                <ListItemButton\r\n                    sx={{ pr: '1.5rem' }}\r\n                    onClick={() => {\r\n                        setOpen(false);\r\n                        setImageDialogOpen(true);\r\n                    }}\r\n                >\r\n                    <ListItemIcon>\r\n                        <ImageIcon />\r\n                    </ListItemIcon>\r\n                    <ListItemText>\r\n                        Use custom images...\r\n                    </ListItemText>\r\n                </ListItemButton>\r\n            </List>\r\n        </Drawer>\r\n    )\r\n}","import React, { useState } from 'react';\n\nimport AppBar from '@material-ui/core/AppBar';\nimport Container from '@material-ui/core/Container';\nimport IconButton from '@material-ui/core/IconButton';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport MenuIcon from '@material-ui/icons/Menu';\n\nimport Game from './game/Game';\nimport ImageDialog from './ImageDialog';\nimport SettingsDrawer from './SettingsDrawer';\n\nexport default function App() {\n    const [menuOpen, setMenuOpen] = useState(false);\n    const [dialogOpen, setDialogOpen] = useState(false);\n\n    return (\n        <>\n            <AppBar position='static'>\n                <Toolbar>\n                    <IconButton\n                        size='large'\n                        edge='start'\n                        color='inherit'\n                        aria-label='Menu'\n                        sx={{ mr: 2 }}\n                        onClick={() => setMenuOpen(true)}\n                    >\n                        <MenuIcon />\n                    </IconButton>\n                    <Typography variant='h6' component='div' sx={{ flexGrow: 1 }}>\n                        2048\n                    </Typography>\n                </Toolbar>\n            </AppBar>\n\n            <SettingsDrawer isOpen={menuOpen} setOpen={setMenuOpen} setImageDialogOpen={setDialogOpen} />\n\n            <ImageDialog isOpen={dialogOpen} setOpen={setDialogOpen} />\n\n            <Container\n                sx={{\n                    display: 'flex',\n                    justifyContent: 'center',\n                    my: '.5rem',\n                }}\n            >\n                <Game />\n            </Container>\n        </>\n    );\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport { CssBaseline } from '@material-ui/core';\n\nimport '@fontsource/roboto/300.css';\nimport '@fontsource/roboto/400.css';\nimport '@fontsource/roboto/500.css';\nimport '@fontsource/roboto/700.css';\n\nReactDOM.render(\n    <React.StrictMode>\n        <>\n            <CssBaseline />\n            <App />\n        </>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}